From c7000fac10e55c1309d433b217a071f526215dae Mon Sep 17 00:00:00 2001
From: Nobuhiko Tanibata <NOBUHIKO_TANIBATA@denso.co.jp>
Date: Thu, 15 Oct 2015 19:30:18 +0900
Subject: [PATCH 1/2] gl-renderer for renesas board

---
 src/gl-renderer.c | 879 ++++++------------------------------------------------
 src/gl-renderer.h |  69 ++---
 2 files changed, 110 insertions(+), 838 deletions(-)

diff --git a/src/gl-renderer.c b/src/gl-renderer.c
index d7231f4..e249487 100644
--- a/src/gl-renderer.c
+++ b/src/gl-renderer.c
@@ -1,49 +1,42 @@
 /*
  * Copyright © 2012 Intel Corporation
- * Copyright © 2015 Collabora, Ltd.
  *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
  *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial
- * portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
 #include "config.h"
+#include "helpers.h"
 
 #include <GLES2/gl2.h>
 #include <GLES2/gl2ext.h>
 
-#include <stdbool.h>
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
 #include <float.h>
 #include <assert.h>
 #include <linux/input.h>
-#include <drm_fourcc.h>
 
 #include "gl-renderer.h"
 #include "vertex-clipping.h"
-#include "linux-dmabuf.h"
-#include "linux-dmabuf-server-protocol.h"
 
-#include "shared/helpers.h"
+#include <EGL/eglext.h>
 #include "weston-egl-ext.h"
 
 struct gl_shader {
@@ -78,7 +71,6 @@ struct gl_border_image {
 struct gl_output_state {
 	EGLSurface egl_surface;
 	pixman_region32_t buffer_damage[BUFFER_DAMAGE_COUNT];
-	int buffer_damage_index;
 	enum gl_border_status border_damage[BUFFER_DAMAGE_COUNT];
 	struct gl_border_image borders[4];
 	enum gl_border_status border_status;
@@ -93,18 +85,6 @@ enum buffer_type {
 	BUFFER_TYPE_EGL
 };
 
-struct gl_renderer;
-
-struct egl_image {
-	struct gl_renderer *renderer;
-	EGLImageKHR image;
-	int refcount;
-
-	/* Only used for dmabuf imported buffer */
-	struct linux_dmabuf_buffer *dmabuf;
-	struct wl_list link;
-};
-
 struct gl_surface_state {
 	GLfloat color[4];
 	struct gl_shader *shader;
@@ -120,7 +100,7 @@ struct gl_surface_state {
 	GLenum gl_format;
 	GLenum gl_pixel_type;
 
-	struct egl_image* images[3];
+	EGLImageKHR images[3];
 	GLenum target;
 	int num_images;
 
@@ -158,8 +138,6 @@ struct gl_renderer {
 	PFNEGLSWAPBUFFERSWITHDAMAGEEXTPROC swap_buffers_with_damage;
 #endif
 
-	PFNEGLCREATEPLATFORMWINDOWSURFACEEXTPROC create_platform_window;
-
 	int has_unpack_subimage;
 
 	PFNEGLBINDWAYLANDDISPLAYWL bind_display;
@@ -173,9 +151,6 @@ struct gl_renderer {
 
 	int has_configless_context;
 
-	int has_dmabuf_import;
-	struct wl_list dmabuf_images;
-
 	struct gl_shader texture_shader_rgba;
 	struct gl_shader texture_shader_rgbx;
 	struct gl_shader texture_shader_egl_external;
@@ -189,8 +164,6 @@ struct gl_renderer {
 	struct wl_signal destroy_signal;
 };
 
-static PFNEGLGETPLATFORMDISPLAYEXTPROC get_platform_display = NULL;
-
 static inline struct gl_output_state *
 get_output_state(struct weston_output *output)
 {
@@ -215,56 +188,6 @@ get_renderer(struct weston_compositor *ec)
 	return (struct gl_renderer *)ec->renderer;
 }
 
-static struct egl_image*
-egl_image_create(struct gl_renderer *gr, EGLenum target,
-		 EGLClientBuffer buffer, const EGLint *attribs)
-{
-	struct egl_image *img;
-
-	img = zalloc(sizeof *img);
-	wl_list_init(&img->link);
-	img->renderer = gr;
-	img->refcount = 1;
-	img->image = gr->create_image(gr->egl_display, EGL_NO_CONTEXT,
-				      target, buffer, attribs);
-
-	if (img->image == EGL_NO_IMAGE_KHR) {
-		free(img);
-		return NULL;
-	}
-
-	return img;
-}
-
-static struct egl_image*
-egl_image_ref(struct egl_image *image)
-{
-	image->refcount++;
-
-	return image;
-}
-
-static int
-egl_image_unref(struct egl_image *image)
-{
-	struct gl_renderer *gr = image->renderer;
-
-	assert(image->refcount > 0);
-
-	image->refcount--;
-	if (image->refcount > 0)
-		return image->refcount;
-
-	if (image->dmabuf)
-		linux_dmabuf_buffer_set_user_data(image->dmabuf, NULL, NULL);
-
-	gr->destroy_image(gr->egl_display, image->image);
-	wl_list_remove(&image->link);
-	free(image);
-
-	return 0;
-}
-
 static const char *
 egl_error_string(EGLint code)
 {
@@ -376,55 +299,6 @@ calculate_edges(struct weston_view *ev, pixman_box32_t *rect,
 	return n;
 }
 
-static bool
-merge_down(pixman_box32_t *a, pixman_box32_t *b, pixman_box32_t *merge)
-{
-	if (a->x1 == b->x1 && a->x2 == b->x2 && a->y1 == b->y2) {
-		merge->x1 = a->x1;
-		merge->x2 = a->x2;
-		merge->y1 = b->y1;
-		merge->y2 = a->y2;
-		return true;
-	}
-	return false;
-}
-
-static int
-compress_bands(pixman_box32_t *inrects, int nrects,
-		   pixman_box32_t **outrects)
-{
-	bool merged;
-	pixman_box32_t *out, merge_rect;
-	int i, j, nout;
-
-	if (!nrects) {
-		*outrects = NULL;
-		return 0;
-	}
-
-	/* nrects is an upper bound - we're not too worried about
-	 * allocating a little extra
-	 */
-	out = malloc(sizeof(pixman_box32_t) * nrects);
-	out[0] = inrects[0];
-	nout = 1;
-	for (i = 1; i < nrects; i++) {
-		for (j = 0; j < nout; j++) {
-			merged = merge_down(&inrects[i], &out[j], &merge_rect);
-			if (merged) {
-				out[j] = merge_rect;
-				break;
-			}
-		}
-		if (!merged) {
-			out[nout] = inrects[i];
-			nout++;
-		}
-	}
-	*outrects = out;
-	return nout;
-}
-
 static int
 texture_region(struct weston_view *ev, pixman_region32_t *region,
 		pixman_region32_t *surf_region)
@@ -435,20 +309,11 @@ texture_region(struct weston_view *ev, pixman_region32_t *region,
 	GLfloat *v, inv_width, inv_height;
 	unsigned int *vtxcnt, nvtx = 0;
 	pixman_box32_t *rects, *surf_rects;
-	pixman_box32_t *raw_rects;
-	int i, j, k, nrects, nsurf, raw_nrects;
-	bool used_band_compression;
-	raw_rects = pixman_region32_rectangles(region, &raw_nrects);
+	int i, j, k, nrects, nsurf;
+
+	rects = pixman_region32_rectangles(region, &nrects);
 	surf_rects = pixman_region32_rectangles(surf_region, &nsurf);
 
-	if (raw_nrects < 4) {
-		used_band_compression = false;
-		nrects = raw_nrects;
-		rects = raw_rects;
-	} else {
-		nrects = compress_bands(raw_rects, raw_nrects, &rects);
-		used_band_compression = true;
-	}
 	/* worst case we can have 8 vertices per rect (ie. clipped into
 	 * an octagon):
 	 */
@@ -507,8 +372,6 @@ texture_region(struct weston_view *ev, pixman_region32_t *region,
 		}
 	}
 
-	if (used_band_compression)
-		free(rects);
 	return nvtx;
 }
 
@@ -671,8 +534,6 @@ draw_view(struct weston_view *ev, struct weston_output *output,
 	struct gl_surface_state *gs = get_surface_state(ev->surface);
 	/* repaint bounding region in global coordinates: */
 	pixman_region32_t repaint;
-	/* opaque region in surface coordinates: */
-	pixman_region32_t surface_opaque;
 	/* non-opaque region in surface coordinates: */
 	pixman_region32_t surface_blend;
 	GLint filter;
@@ -718,22 +579,10 @@ draw_view(struct weston_view *ev, struct weston_output *output,
 	/* blended region is whole surface minus opaque region: */
 	pixman_region32_init_rect(&surface_blend, 0, 0,
 				  ev->surface->width, ev->surface->height);
-	if (ev->geometry.scissor_enabled)
-		pixman_region32_intersect(&surface_blend, &surface_blend,
-					  &ev->geometry.scissor);
-	pixman_region32_subtract(&surface_blend, &surface_blend,
-				 &ev->surface->opaque);
+	pixman_region32_subtract(&surface_blend, &surface_blend, &ev->surface->opaque);
 
 	/* XXX: Should we be using ev->transform.opaque here? */
-	pixman_region32_init(&surface_opaque);
-	if (ev->geometry.scissor_enabled)
-		pixman_region32_intersect(&surface_opaque,
-					  &ev->surface->opaque,
-					  &ev->geometry.scissor);
-	else
-		pixman_region32_copy(&surface_opaque, &ev->surface->opaque);
-
-	if (pixman_region32_not_empty(&surface_opaque)) {
+	if (pixman_region32_not_empty(&ev->surface->opaque)) {
 		if (gs->shader == &gr->texture_shader_rgba) {
 			/* Special case for RGBA textures with possibly
 			 * bad data in alpha channel: use the shader
@@ -749,7 +598,7 @@ draw_view(struct weston_view *ev, struct weston_output *output,
 		else
 			glDisable(GL_BLEND);
 
-		repaint_region(ev, &repaint, &surface_opaque);
+		repaint_region(ev, &repaint, &ev->surface->opaque);
 	}
 
 	if (pixman_region32_not_empty(&surface_blend)) {
@@ -759,7 +608,6 @@ draw_view(struct weston_view *ev, struct weston_output *output,
 	}
 
 	pixman_region32_fini(&surface_blend);
-	pixman_region32_fini(&surface_opaque);
 
 out:
 	pixman_region32_fini(&repaint);
@@ -972,7 +820,7 @@ output_get_damage(struct weston_output *output,
 		*border_damage = BORDER_ALL_DIRTY;
 	} else {
 		for (i = 0; i < buffer_age - 1; i++)
-			*border_damage |= go->border_damage[(go->buffer_damage_index + i) % BUFFER_DAMAGE_COUNT];
+			*border_damage |= go->border_damage[i];
 
 		if (*border_damage & BORDER_SIZE_CHANGED) {
 			/* If we've had a resize, we have to do a full
@@ -983,7 +831,7 @@ output_get_damage(struct weston_output *output,
 			for (i = 0; i < buffer_age - 1; i++)
 				pixman_region32_union(buffer_damage,
 						      buffer_damage,
-						      &go->buffer_damage[(go->buffer_damage_index + i) % BUFFER_DAMAGE_COUNT]);
+						      &go->buffer_damage[i]);
 		}
 	}
 }
@@ -995,25 +843,21 @@ output_rotate_damage(struct weston_output *output,
 {
 	struct gl_output_state *go = get_output_state(output);
 	struct gl_renderer *gr = get_renderer(output->compositor);
+	int i;
 
 	if (!gr->has_egl_buffer_age)
 		return;
 
-	go->buffer_damage_index += BUFFER_DAMAGE_COUNT - 1;
-	go->buffer_damage_index %= BUFFER_DAMAGE_COUNT;
+	for (i = BUFFER_DAMAGE_COUNT - 1; i >= 1; i--) {
+		go->border_damage[i] = go->border_damage[i - 1];
+		pixman_region32_copy(&go->buffer_damage[i],
+				     &go->buffer_damage[i - 1]);
+	}
 
-	pixman_region32_copy(&go->buffer_damage[go->buffer_damage_index], output_damage);
-	go->border_damage[go->buffer_damage_index] = border_status;
+	go->border_damage[0] = border_status;
+	pixman_region32_copy(&go->buffer_damage[0], output_damage);
 }
 
-/* NOTE: We now allow falling back to ARGB gl visuals when XRGB is
- * unavailable, so we're assuming the background has no transparency
- * and that everything with a blend, like drop shadows, will have something
- * opaque (like the background) drawn underneath it.
- *
- * Depending on the underlying hardware, violating that assumption could
- * result in seeing through to another display plane.
- */
 static void
 gl_renderer_repaint_output(struct weston_output *output,
 			      pixman_region32_t *output_damage)
@@ -1031,9 +875,6 @@ gl_renderer_repaint_output(struct weston_output *output,
 	pixman_region32_t buffer_damage, total_damage;
 	enum gl_border_status border_damage = BORDER_STATUS_CLEAN;
 
-	if (use_output(output) < 0)
-		return;
-
 	/* Calculate the viewport */
 	glViewport(go->borders[GL_RENDERER_BORDER_LEFT].width,
 		   go->borders[GL_RENDERER_BORDER_BOTTOM].height,
@@ -1358,10 +1199,8 @@ gl_renderer_attach_egl(struct weston_surface *es, struct weston_buffer *buffer,
 	gr->query_buffer(gr->egl_display, buffer->legacy_buffer,
 			 EGL_WAYLAND_Y_INVERTED_WL, &buffer->y_inverted);
 
-	for (i = 0; i < gs->num_images; i++) {
-		egl_image_unref(gs->images[i]);
-		gs->images[i] = NULL;
-	}
+	for (i = 0; i < gs->num_images; i++)
+		gr->destroy_image(gr->egl_display, gs->images[i]);
 	gs->num_images = 0;
 	gs->target = GL_TEXTURE_2D;
 	switch (format) {
@@ -1395,7 +1234,8 @@ gl_renderer_attach_egl(struct weston_surface *es, struct weston_buffer *buffer,
 		attribs[0] = EGL_WAYLAND_PLANE_WL;
 		attribs[1] = i;
 		attribs[2] = EGL_NONE;
-		gs->images[i] = egl_image_create(gr,
+		gs->images[i] = gr->create_image(gr->egl_display,
+						 NULL,
 						 EGL_WAYLAND_BUFFER_WL,
 						 buffer->legacy_buffer,
 						 attribs);
@@ -1408,7 +1248,7 @@ gl_renderer_attach_egl(struct weston_surface *es, struct weston_buffer *buffer,
 		glActiveTexture(GL_TEXTURE0 + i);
 		glBindTexture(gs->target, gs->textures[i]);
 		gr->image_target_texture_2d(gs->target,
-					    gs->images[i]->image);
+					    gs->images[i]);
 	}
 
 	gs->pitch = buffer->width;
@@ -1418,210 +1258,12 @@ gl_renderer_attach_egl(struct weston_surface *es, struct weston_buffer *buffer,
 }
 
 static void
-gl_renderer_destroy_dmabuf(struct linux_dmabuf_buffer *dmabuf)
-{
-	struct egl_image *image = dmabuf->user_data;
-
-	egl_image_unref(image);
-}
-
-static struct egl_image *
-import_dmabuf(struct gl_renderer *gr,
-	      struct linux_dmabuf_buffer *dmabuf)
-{
-	struct egl_image *image;
-	EGLint attribs[30];
-	int atti = 0;
-
-	image = linux_dmabuf_buffer_get_user_data(dmabuf);
-	if (image)
-		return egl_image_ref(image);
-
-	/* This requires the Mesa commit in
-	 * Mesa 10.3 (08264e5dad4df448e7718e782ad9077902089a07) or
-	 * Mesa 10.2.7 (55d28925e6109a4afd61f109e845a8a51bd17652).
-	 * Otherwise Mesa closes the fd behind our back and re-importing
-	 * will fail.
-	 * https://bugs.freedesktop.org/show_bug.cgi?id=76188
-	 */
-
-	attribs[atti++] = EGL_WIDTH;
-	attribs[atti++] = dmabuf->width;
-	attribs[atti++] = EGL_HEIGHT;
-	attribs[atti++] = dmabuf->height;
-	attribs[atti++] = EGL_LINUX_DRM_FOURCC_EXT;
-	attribs[atti++] = dmabuf->format;
-	/* XXX: Add modifier here when supported */
-
-	if (dmabuf->n_planes > 0) {
-		attribs[atti++] = EGL_DMA_BUF_PLANE0_FD_EXT;
-		attribs[atti++] = dmabuf->dmabuf_fd[0];
-		attribs[atti++] = EGL_DMA_BUF_PLANE0_OFFSET_EXT;
-		attribs[atti++] = dmabuf->offset[0];
-		attribs[atti++] = EGL_DMA_BUF_PLANE0_PITCH_EXT;
-		attribs[atti++] = dmabuf->stride[0];
-	}
-
-	if (dmabuf->n_planes > 1) {
-		attribs[atti++] = EGL_DMA_BUF_PLANE1_FD_EXT;
-		attribs[atti++] = dmabuf->dmabuf_fd[1];
-		attribs[atti++] = EGL_DMA_BUF_PLANE1_OFFSET_EXT;
-		attribs[atti++] = dmabuf->offset[1];
-		attribs[atti++] = EGL_DMA_BUF_PLANE1_PITCH_EXT;
-		attribs[atti++] = dmabuf->stride[1];
-	}
-
-	if (dmabuf->n_planes > 2) {
-		attribs[atti++] = EGL_DMA_BUF_PLANE2_FD_EXT;
-		attribs[atti++] = dmabuf->dmabuf_fd[2];
-		attribs[atti++] = EGL_DMA_BUF_PLANE2_OFFSET_EXT;
-		attribs[atti++] = dmabuf->offset[2];
-		attribs[atti++] = EGL_DMA_BUF_PLANE2_PITCH_EXT;
-		attribs[atti++] = dmabuf->stride[2];
-	}
-
-	attribs[atti++] = EGL_NONE;
-
-	image = egl_image_create(gr, EGL_LINUX_DMA_BUF_EXT, NULL,
-				 attribs);
-
-	if (!image)
-		return NULL;
-
-	/* The cache owns one ref. The caller gets another. */
-	image->dmabuf = dmabuf;
-	wl_list_insert(&gr->dmabuf_images, &image->link);
-	linux_dmabuf_buffer_set_user_data(dmabuf, egl_image_ref(image),
-		gl_renderer_destroy_dmabuf);
-
-	return image;
-}
-
-static bool
-gl_renderer_import_dmabuf(struct weston_compositor *ec,
-			  struct linux_dmabuf_buffer *dmabuf)
-{
-	struct gl_renderer *gr = get_renderer(ec);
-	struct egl_image *image;
-	int i;
-
-	assert(gr->has_dmabuf_import);
-
-	for (i = 0; i < dmabuf->n_planes; i++) {
-		/* EGL import does not have modifiers */
-		if (dmabuf->modifier[i] != 0)
-			return false;
-	}
-
-	/* reject all flags we do not recognize or handle */
-	if (dmabuf->flags & ~ZLINUX_BUFFER_PARAMS_FLAGS_Y_INVERT)
-		return false;
-
-	image = import_dmabuf(gr, dmabuf);
-	if (!image)
-		return false;
-
-	/* Cache retains a ref. */
-	egl_image_unref(image);
-
-	return true;
-}
-
-static GLenum
-choose_texture_target(struct linux_dmabuf_buffer *dmabuf)
-{
-	if (dmabuf->n_planes > 1)
-		return GL_TEXTURE_EXTERNAL_OES;
-
-	switch (dmabuf->format & ~DRM_FORMAT_BIG_ENDIAN) {
-	case DRM_FORMAT_YUYV:
-	case DRM_FORMAT_YVYU:
-	case DRM_FORMAT_UYVY:
-	case DRM_FORMAT_VYUY:
-	case DRM_FORMAT_AYUV:
-		return GL_TEXTURE_EXTERNAL_OES;
-	default:
-		return GL_TEXTURE_2D;
-	}
-}
-
-static void
-gl_renderer_attach_dmabuf(struct weston_surface *surface,
-			  struct weston_buffer *buffer,
-			  struct linux_dmabuf_buffer *dmabuf)
-{
-	struct gl_renderer *gr = get_renderer(surface->compositor);
-	struct gl_surface_state *gs = get_surface_state(surface);
-	int i;
-
-	if (!gr->has_dmabuf_import) {
-		linux_dmabuf_buffer_send_server_error(dmabuf,
-				"EGL dmabuf import not supported");
-		return;
-	}
-
-	buffer->width = dmabuf->width;
-	buffer->height = dmabuf->height;
-	buffer->y_inverted =
-		!!(dmabuf->flags & ZLINUX_BUFFER_PARAMS_FLAGS_Y_INVERT);
-
-	for (i = 0; i < gs->num_images; i++)
-		egl_image_unref(gs->images[i]);
-	gs->num_images = 0;
-
-	gs->target = choose_texture_target(dmabuf);
-	switch (gs->target) {
-	case GL_TEXTURE_2D:
-		gs->shader = &gr->texture_shader_rgba;
-		break;
-	default:
-		gs->shader = &gr->texture_shader_egl_external;
-	}
-
-	/*
-	 * We try to always hold an imported EGLImage from the dmabuf
-	 * to prevent the client from preventing re-imports. But, we also
-	 * need to re-import every time the contents may change because
-	 * GL driver's caching may need flushing.
-	 *
-	 * Here we release the cache reference which has to be final.
-	 */
-	gs->images[0] = linux_dmabuf_buffer_get_user_data(dmabuf);
-	if (gs->images[0]) {
-		int ret;
-
-		ret = egl_image_unref(gs->images[0]);
-		assert(ret == 0);
-	}
-
-	gs->images[0] = import_dmabuf(gr, dmabuf);
-	if (!gs->images[0]) {
-		linux_dmabuf_buffer_send_server_error(dmabuf,
-				"EGL dmabuf import failed");
-		return;
-	}
-	gs->num_images = 1;
-
-	ensure_textures(gs, 1);
-
-	glActiveTexture(GL_TEXTURE0);
-	glBindTexture(gs->target, gs->textures[0]);
-	gr->image_target_texture_2d(gs->target, gs->images[0]->image);
-
-	gs->pitch = buffer->width;
-	gs->height = buffer->height;
-	gs->buffer_type = BUFFER_TYPE_EGL;
-	gs->y_inverted = buffer->y_inverted;
-}
-
-static void
 gl_renderer_attach(struct weston_surface *es, struct weston_buffer *buffer)
 {
 	struct weston_compositor *ec = es->compositor;
 	struct gl_renderer *gr = get_renderer(ec);
 	struct gl_surface_state *gs = get_surface_state(es);
 	struct wl_shm_buffer *shm_buffer;
-	struct linux_dmabuf_buffer *dmabuf;
 	EGLint format;
 	int i;
 
@@ -1629,7 +1271,7 @@ gl_renderer_attach(struct weston_surface *es, struct weston_buffer *buffer)
 
 	if (!buffer) {
 		for (i = 0; i < gs->num_images; i++) {
-			egl_image_unref(gs->images[i]);
+			gr->destroy_image(gr->egl_display, gs->images[i]);
 			gs->images[i] = NULL;
 		}
 		gs->num_images = 0;
@@ -1647,8 +1289,6 @@ gl_renderer_attach(struct weston_surface *es, struct weston_buffer *buffer)
 	else if (gr->query_buffer(gr->egl_display, (void *) buffer->resource,
 				  EGL_TEXTURE_FORMAT, &format))
 		gl_renderer_attach_egl(es, buffer, format);
-	else if ((dmabuf = linux_dmabuf_buffer_get(buffer->resource)))
-		gl_renderer_attach_dmabuf(es, buffer, dmabuf);
 	else {
 		weston_log("unhandled buffer type!\n");
 		weston_buffer_reference(&gs->buffer_ref, NULL);
@@ -1668,159 +1308,11 @@ gl_renderer_surface_set_color(struct weston_surface *surface,
 	gs->color[1] = green;
 	gs->color[2] = blue;
 	gs->color[3] = alpha;
-	gs->buffer_type = BUFFER_TYPE_SOLID;
-	gs->pitch = 1;
-	gs->height = 1;
 
 	gs->shader = &gr->solid_shader;
 }
 
 static void
-gl_renderer_surface_get_content_size(struct weston_surface *surface,
-				     int *width, int *height)
-{
-	struct gl_surface_state *gs = get_surface_state(surface);
-
-	if (gs->buffer_type == BUFFER_TYPE_NULL) {
-		*width = 0;
-		*height = 0;
-	} else {
-		*width = gs->pitch;
-		*height = gs->height;
-	}
-}
-
-static uint32_t
-pack_color(pixman_format_code_t format, float *c)
-{
-	uint8_t r = round(c[0] * 255.0f);
-	uint8_t g = round(c[1] * 255.0f);
-	uint8_t b = round(c[2] * 255.0f);
-	uint8_t a = round(c[3] * 255.0f);
-
-	switch (format) {
-	case PIXMAN_a8b8g8r8:
-		return (a << 24) | (b << 16) | (g << 8) | r;
-	default:
-		assert(0);
-		return 0;
-	}
-}
-
-static int
-gl_renderer_surface_copy_content(struct weston_surface *surface,
-				 void *target, size_t size,
-				 int src_x, int src_y,
-				 int width, int height)
-{
-	static const GLfloat verts[4 * 2] = {
-		0.0f, 0.0f,
-		1.0f, 0.0f,
-		1.0f, 1.0f,
-		0.0f, 1.0f
-	};
-	static const GLfloat projmat_normal[16] = { /* transpose */
-		 2.0f,  0.0f, 0.0f, 0.0f,
-		 0.0f,  2.0f, 0.0f, 0.0f,
-		 0.0f,  0.0f, 1.0f, 0.0f,
-		-1.0f, -1.0f, 0.0f, 1.0f
-	};
-	static const GLfloat projmat_yinvert[16] = { /* transpose */
-		 2.0f,  0.0f, 0.0f, 0.0f,
-		 0.0f, -2.0f, 0.0f, 0.0f,
-		 0.0f,  0.0f, 1.0f, 0.0f,
-		-1.0f,  1.0f, 0.0f, 1.0f
-	};
-	const pixman_format_code_t format = PIXMAN_a8b8g8r8;
-	const size_t bytespp = 4; /* PIXMAN_a8b8g8r8 */
-	const GLenum gl_format = GL_RGBA; /* PIXMAN_a8b8g8r8 little-endian */
-	struct gl_renderer *gr = get_renderer(surface->compositor);
-	struct gl_surface_state *gs = get_surface_state(surface);
-	int cw, ch;
-	GLuint fbo;
-	GLuint tex;
-	GLenum status;
-	const GLfloat *proj;
-	int i;
-
-	gl_renderer_surface_get_content_size(surface, &cw, &ch);
-
-	switch (gs->buffer_type) {
-	case BUFFER_TYPE_NULL:
-		return -1;
-	case BUFFER_TYPE_SOLID:
-		*(uint32_t *)target = pack_color(format, gs->color);
-		return 0;
-	case BUFFER_TYPE_SHM:
-		gl_renderer_flush_damage(surface);
-		/* fall through */
-	case BUFFER_TYPE_EGL:
-		break;
-	}
-
-	glGenTextures(1, &tex);
-	glBindTexture(GL_TEXTURE_2D, tex);
-	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, cw, ch,
-		     0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
-	glBindTexture(GL_TEXTURE_2D, 0);
-
-	glGenFramebuffers(1, &fbo);
-	glBindFramebuffer(GL_FRAMEBUFFER, fbo);
-	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
-			       GL_TEXTURE_2D, tex, 0);
-
-	status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
-	if (status != GL_FRAMEBUFFER_COMPLETE) {
-		weston_log("%s: fbo error: %#x\n", __func__, status);
-		glDeleteFramebuffers(1, &fbo);
-		glDeleteTextures(1, &tex);
-		return -1;
-	}
-
-	glViewport(0, 0, cw, ch);
-	glDisable(GL_BLEND);
-	use_shader(gr, gs->shader);
-	if (gs->y_inverted)
-		proj = projmat_normal;
-	else
-		proj = projmat_yinvert;
-
-	glUniformMatrix4fv(gs->shader->proj_uniform, 1, GL_FALSE, proj);
-	glUniform1f(gs->shader->alpha_uniform, 1.0f);
-
-	for (i = 0; i < gs->num_textures; i++) {
-		glUniform1i(gs->shader->tex_uniforms[i], i);
-
-		glActiveTexture(GL_TEXTURE0 + i);
-		glBindTexture(gs->target, gs->textures[i]);
-		glTexParameteri(gs->target, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-		glTexParameteri(gs->target, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-	}
-
-	/* position: */
-	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, verts);
-	glEnableVertexAttribArray(0);
-
-	/* texcoord: */
-	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, verts);
-	glEnableVertexAttribArray(1);
-
-	glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
-
-	glDisableVertexAttribArray(1);
-	glDisableVertexAttribArray(0);
-
-	glPixelStorei(GL_PACK_ALIGNMENT, bytespp);
-	glReadPixels(src_x, src_y, width, height, gl_format,
-		     GL_UNSIGNED_BYTE, target);
-
-	glDeleteFramebuffers(1, &fbo);
-	glDeleteTextures(1, &tex);
-
-	return 0;
-}
-
-static void
 surface_state_destroy(struct gl_surface_state *gs, struct gl_renderer *gr)
 {
 	int i;
@@ -1833,7 +1325,7 @@ surface_state_destroy(struct gl_surface_state *gs, struct gl_renderer *gr)
 	glDeleteTextures(gs->num_textures, gs->textures);
 
 	for (i = 0; i < gs->num_images; i++)
-		egl_image_unref(gs->images[i]);
+		gr->destroy_image(gr->egl_display, gs->images[i]);
 
 	weston_buffer_reference(&gs->buffer_ref, NULL);
 	pixman_region32_fini(&gs->texture_damage);
@@ -1874,8 +1366,8 @@ gl_renderer_create_surface(struct weston_surface *surface)
 	struct gl_surface_state *gs;
 	struct gl_renderer *gr = get_renderer(surface->compositor);
 
-	gs = zalloc(sizeof *gs);
-	if (gs == NULL)
+	gs = calloc(1, sizeof *gs);
+	if (!gs)
 		return -1;
 
 	/* A buffer is never attached to solid color surfaces, yet
@@ -2179,74 +1671,48 @@ log_egl_config_info(EGLDisplay egldpy, EGLConfig eglconfig)
 }
 
 static int
-match_config_to_visual(EGLDisplay egl_display,
-		       EGLint visual_id,
-		       EGLConfig *configs,
-		       int count)
-{
-	int i;
-
-	for (i = 0; i < count; ++i) {
-		EGLint id;
-
-		if (!eglGetConfigAttrib(egl_display,
-				configs[i], EGL_NATIVE_VISUAL_ID,
-				&id))
-			continue;
-
-		if (id == visual_id)
-			return i;
-	}
-
-	return -1;
-}
-
-static int
 egl_choose_config(struct gl_renderer *gr, const EGLint *attribs,
-		  const EGLint *visual_id, const int n_ids,
+		  const EGLint *visual_id,
 		  EGLConfig *config_out)
 {
 	EGLint count = 0;
 	EGLint matched = 0;
 	EGLConfig *configs;
-	int i, config_index = -1;
+	int i;
 
-	if (!eglGetConfigs(gr->egl_display, NULL, 0, &count) || count < 1) {
-		weston_log("No EGL configs to choose from.\n");
+	if (!eglGetConfigs(gr->egl_display, NULL, 0, &count) || count < 1)
 		return -1;
-	}
+
 	configs = calloc(count, sizeof *configs);
 	if (!configs)
 		return -1;
 
 	if (!eglChooseConfig(gr->egl_display, attribs, configs,
-			      count, &matched) || !matched) {
-		weston_log("No EGL configs with appropriate attributes.\n");
+			      count, &matched))
 		goto out;
-	}
 
-	if (!visual_id)
-		config_index = 0;
+	for (i = 0; i < matched; ++i) {
+		EGLint id;
 
-	for (i = 0; config_index == -1 && i < n_ids; i++)
-		config_index = match_config_to_visual(gr->egl_display,
-						      visual_id[i],
-						      configs,
-						      matched);
+		if (visual_id) {
+			if (!eglGetConfigAttrib(gr->egl_display,
+					configs[i], EGL_NATIVE_VISUAL_ID,
+					&id))
+				continue;
 
-	if (config_index != -1)
-		*config_out = configs[config_index];
+			if (id != 0 && id != *visual_id)
+				continue;
+		}
+
+		*config_out = configs[i];
+
+		free(configs);
+		return 0;
+	}
 
 out:
 	free(configs);
-	if (config_index == -1)
-		return -1;
-
-	if (i > 1)
-		weston_log("Unable to use first choice EGL config with id"
-			   " 0x%x, succeeded with alternate id 0x%x.\n",
-			   visual_id[0], visual_id[i - 1]);
-	return 0;
+	return -1;
 }
 
 static void
@@ -2280,11 +1746,9 @@ gl_renderer_setup(struct weston_compositor *ec, EGLSurface egl_surface);
 
 static int
 gl_renderer_output_create(struct weston_output *output,
-			  EGLNativeWindowType window_for_legacy,
-			  void *window_for_platform,
+			  EGLNativeWindowType window,
 			  const EGLint *attribs,
-			  const EGLint *visual_id,
-			  int n_ids)
+			  const EGLint *visual_id)
 {
 	struct weston_compositor *ec = output->compositor;
 	struct gl_renderer *gr = get_renderer(ec);
@@ -2292,8 +1756,7 @@ gl_renderer_output_create(struct weston_output *output,
 	EGLConfig egl_config;
 	int i;
 
-	if (egl_choose_config(gr, attribs, visual_id,
-			      n_ids, &egl_config) == -1) {
+	if (egl_choose_config(gr, attribs, visual_id, &egl_config) == -1) {
 		weston_log("failed to choose EGL config for output\n");
 		return -1;
 	}
@@ -2306,22 +1769,15 @@ gl_renderer_output_create(struct weston_output *output,
 		return -1;
 	}
 
-	go = zalloc(sizeof *go);
-	if (go == NULL)
+	go = calloc(1, sizeof *go);
+
+	if (!go)
 		return -1;
 
-	if (gr->create_platform_window) {
-		go->egl_surface =
-			gr->create_platform_window(gr->egl_display,
-						   egl_config,
-						   window_for_platform,
-						   NULL);
-	} else {
-		go->egl_surface =
-			eglCreateWindowSurface(gr->egl_display,
-					       egl_config,
-					       window_for_legacy, NULL);
-	}
+	go->egl_surface =
+		eglCreateWindowSurface(gr->egl_display,
+				       egl_config,
+				       window, NULL);
 
 	if (go->egl_surface == EGL_NO_SURFACE) {
 		weston_log("failed to create egl surface\n");
@@ -2370,7 +1826,6 @@ static void
 gl_renderer_destroy(struct weston_compositor *ec)
 {
 	struct gl_renderer *gr = get_renderer(ec);
-	struct egl_image *image, *next;
 
 	wl_signal_emit(&gr->destroy_signal, gr);
 
@@ -2382,14 +1837,6 @@ gl_renderer_destroy(struct weston_compositor *ec)
 		       EGL_NO_SURFACE, EGL_NO_SURFACE,
 		       EGL_NO_CONTEXT);
 
-
-	wl_list_for_each_safe(image, next, &gr->dmabuf_images, link) {
-		int ret;
-
-		ret = egl_image_unref(image);
-		assert(ret == 0);
-	}
-
 	eglTerminate(gr->egl_display);
 	eglReleaseThread();
 
@@ -2404,24 +1851,6 @@ gl_renderer_destroy(struct weston_compositor *ec)
 	free(gr);
 }
 
-static void
-renderer_setup_egl_client_extensions(struct gl_renderer *gr)
-{
-	const char *extensions;
-
-	extensions = eglQueryString(EGL_NO_DISPLAY, EGL_EXTENSIONS);
-	if (!extensions) {
-		weston_log("Retrieving EGL client extension string failed.\n");
-		return;
-	}
-
-	if (strstr(extensions, "EGL_EXT_platform_base"))
-		gr->create_platform_window =
-			(void *) eglGetProcAddress("eglCreatePlatformWindowSurfaceEXT");
-	else
-		weston_log("warning: EGL_EXT_platform_base not supported.\n");
-}
-
 static int
 gl_renderer_setup_egl_extensions(struct weston_compositor *ec)
 {
@@ -2473,13 +1902,6 @@ gl_renderer_setup_egl_extensions(struct weston_compositor *ec)
 		gr->has_configless_context = 1;
 #endif
 
-#ifdef EGL_EXT_image_dma_buf_import
-	if (strstr(extensions, "EGL_EXT_image_dma_buf_import"))
-		gr->has_dmabuf_import = 1;
-#endif
-
-	renderer_setup_egl_client_extensions(gr);
-
 	return 0;
 }
 
@@ -2503,100 +1925,15 @@ static const EGLint gl_renderer_alpha_attribs[] = {
 	EGL_NONE
 };
 
-/** Checks whether a platform EGL client extension is supported
- *
- * \param ec The weston compositor
- * \param extension_suffix The EGL client extension suffix
- * \return 1 if supported, 0 if using fallbacks, -1 unsupported
- *
- * This function checks whether a specific platform_* extension is supported
- * by EGL.
- *
- * The extension suffix should be the suffix of the platform extension (that
- * specifies a <platform> argument as defined in EGL_EXT_platform_base). For
- * example, passing "foo" will check whether either "EGL_KHR_platform_foo",
- * "EGL_EXT_platform_foo", or "EGL_MESA_platform_foo" is supported.
- *
- * The return value is 1:
- *   - if the supplied EGL client extension is supported.
- * The return value is 0:
- *   - if the platform_base client extension isn't supported so will
- *     fallback to eglGetDisplay and friends.
- * The return value is -1:
- *   - if the supplied EGL client extension is not supported.
- */
 static int
-gl_renderer_supports(struct weston_compositor *ec,
-		     const char *extension_suffix)
-{
-	static const char *extensions = NULL;
-	char s[64];
-
-	if (!extensions) {
-		extensions = (const char *) eglQueryString(
-			EGL_NO_DISPLAY, EGL_EXTENSIONS);
-
-		if (!extensions)
-			return 0;
-
-		log_extensions("EGL client extensions",
-			       extensions);
-	}
-
-	if (!strstr(extensions, "EGL_EXT_platform_base"))
-		return 0;
-
-	snprintf(s, sizeof s, "EGL_KHR_platform_%s", extension_suffix);
-	if (strstr(extensions, s))
-		return 1;
-
-	snprintf(s, sizeof s, "EGL_EXT_platform_%s", extension_suffix);
-	if (strstr(extensions, s))
-		return 1;
-
-	snprintf(s, sizeof s, "EGL_MESA_platform_%s", extension_suffix);
-	if (strstr(extensions, s))
-		return 1;
-
-	/* at this point we definitely have some platform extensions but
-	 * haven't found the supplied platform, so chances are it's
-	 * not supported. */
-
-	return -1;
-}
-
-static const char *
-platform_to_extension(EGLenum platform)
-{
-	switch (platform) {
-	case EGL_PLATFORM_GBM_KHR:
-		return "gbm";
-	case EGL_PLATFORM_WAYLAND_KHR:
-		return "wayland";
-	case EGL_PLATFORM_X11_KHR:
-		return "x11";
-	default:
-		assert(0 && "bad EGL platform enum");
-	}
-}
-
-static int
-gl_renderer_create(struct weston_compositor *ec, EGLenum platform,
-	void *native_window, const EGLint *attribs,
-	const EGLint *visual_id, int n_ids)
+gl_renderer_create(struct weston_compositor *ec, EGLNativeDisplayType display,
+	const EGLint *attribs, const EGLint *visual_id)
 {
 	struct gl_renderer *gr;
 	EGLint major, minor;
-	int supports = 0;
 
-	if (platform) {
-		supports = gl_renderer_supports(
-			ec, platform_to_extension(platform));
-		if (supports < 0)
-			return -1;
-	}
+	gr = calloc(1, sizeof *gr);
 
-	gr = zalloc(sizeof *gr);
 	if (gr == NULL)
 		return -1;
 
@@ -2606,50 +1943,21 @@ gl_renderer_create(struct weston_compositor *ec, EGLenum platform,
 	gr->base.attach = gl_renderer_attach;
 	gr->base.surface_set_color = gl_renderer_surface_set_color;
 	gr->base.destroy = gl_renderer_destroy;
-	gr->base.surface_get_content_size =
-		gl_renderer_surface_get_content_size;
-	gr->base.surface_copy_content = gl_renderer_surface_copy_content;
-	gr->egl_display = NULL;
-
-	/* extension_suffix is supported */
-	if (supports) {
-		if (!get_platform_display) {
-			get_platform_display = (void *) eglGetProcAddress(
-					"eglGetPlatformDisplayEXT");
-		}
-
-		/* also wrap this in the supports check because
-		 * eglGetProcAddress can return non-NULL and still not
-		 * support the feature at runtime, so ensure the
-		 * appropriate extension checks have been done. */
-		if (get_platform_display && platform) {
-			gr->egl_display = get_platform_display(platform,
-							       native_window,
-							       NULL);
-		}
-	}
-
-	if (!gr->egl_display) {
-		weston_log("warning: either no EGL_EXT_platform_base "
-			   "support or specific platform support; "
-			   "falling back to eglGetDisplay.\n");
-		gr->egl_display = eglGetDisplay(native_window);
-	}
 
+	gr->egl_display = eglGetDisplay(display);
 	if (gr->egl_display == EGL_NO_DISPLAY) {
 		weston_log("failed to create display\n");
-		goto fail;
+		goto err_egl;
 	}
 
 	if (!eglInitialize(gr->egl_display, &major, &minor)) {
 		weston_log("failed to initialize display\n");
-		goto fail_with_error;
+		goto err_egl;
 	}
 
-	if (egl_choose_config(gr, attribs, visual_id,
-			      n_ids, &gr->egl_config) < 0) {
+	if (egl_choose_config(gr, attribs, visual_id, &gr->egl_config) < 0) {
 		weston_log("failed to choose EGL config\n");
-		goto fail_terminate;
+		goto err_egl;
 	}
 
 	ec->renderer = &gr->base;
@@ -2658,11 +1966,7 @@ gl_renderer_create(struct weston_compositor *ec, EGLenum platform,
 	ec->capabilities |= WESTON_CAP_VIEW_CLIP_MASK;
 
 	if (gl_renderer_setup_egl_extensions(ec) < 0)
-		goto fail_with_error;
-
-	wl_list_init(&gr->dmabuf_images);
-	if (gr->has_dmabuf_import)
-		gr->base.import_dmabuf = gl_renderer_import_dmabuf;
+		goto err_egl;
 
 	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_RGB565);
 
@@ -2670,11 +1974,8 @@ gl_renderer_create(struct weston_compositor *ec, EGLenum platform,
 
 	return 0;
 
-fail_with_error:
+err_egl:
 	gl_renderer_print_egl_error_state();
-fail_terminate:
-	eglTerminate(gr->egl_display);
-fail:
 	free(gr);
 	return -1;
 }
@@ -2718,8 +2019,8 @@ compile_shaders(struct weston_compositor *ec)
 }
 
 static void
-fragment_debug_binding(struct weston_keyboard *keyboard, uint32_t time,
-		       uint32_t key, void *data)
+fragment_debug_binding(struct weston_seat *seat, uint32_t time, uint32_t key,
+		       void *data)
 {
 	struct weston_compositor *ec = data;
 	struct gl_renderer *gr = get_renderer(ec);
@@ -2744,8 +2045,8 @@ fragment_debug_binding(struct weston_keyboard *keyboard, uint32_t time,
 }
 
 static void
-fan_debug_repaint_binding(struct weston_keyboard *keyboard, uint32_t time,
-			  uint32_t key, void *data)
+fan_debug_repaint_binding(struct weston_seat *seat, uint32_t time, uint32_t key,
+		      void *data)
 {
 	struct weston_compositor *compositor = data;
 	struct gl_renderer *gr = get_renderer(compositor);
diff --git a/src/gl-renderer.h b/src/gl-renderer.h
index 71f6b46..77b1952 100644
--- a/src/gl-renderer.h
+++ b/src/gl-renderer.h
@@ -1,26 +1,23 @@
 /*
  * Copyright © 2012 John Kåre Alsaker
  *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
  *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial
- * portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
 #include "config.h"
@@ -30,40 +27,18 @@
 #ifdef ENABLE_EGL
 
 #include <EGL/egl.h>
-#include <EGL/eglext.h>
 
 #else
 
 typedef int EGLint;
-typedef int EGLenum;
 typedef void *EGLDisplay;
 typedef void *EGLSurface;
-typedef void *EGLConfig;
 typedef intptr_t EGLNativeDisplayType;
 typedef intptr_t EGLNativeWindowType;
 #define EGL_DEFAULT_DISPLAY ((EGLNativeDisplayType)0)
 
-#endif /* ENABLE_EGL */
-
-#ifndef EGL_EXT_platform_base
-typedef EGLDisplay (*PFNEGLGETPLATFORMDISPLAYEXTPROC) (EGLenum platform, void *native_display, const EGLint *attrib_list);
-typedef EGLSurface (*PFNEGLCREATEPLATFORMWINDOWSURFACEEXTPROC) (EGLDisplay dpy, EGLConfig config, void *native_window, const EGLint *attrib_list);
 #endif
 
-#ifndef EGL_PLATFORM_GBM_KHR
-#define EGL_PLATFORM_GBM_KHR 0x31D7
-#endif
-
-#ifndef EGL_PLATFORM_WAYLAND_KHR
-#define EGL_PLATFORM_WAYLAND_KHR 0x31D8
-#endif
-
-#ifndef EGL_PLATFORM_X11_KHR
-#define EGL_PLATFORM_X11_KHR 0x31D5
-#endif
-
-#define NO_EGL_PLATFORM 0
-
 enum gl_renderer_border_side {
 	GL_RENDERER_BORDER_TOP = 0,
 	GL_RENDERER_BORDER_LEFT = 1,
@@ -76,20 +51,16 @@ struct gl_renderer_interface {
 	const EGLint *alpha_attribs;
 
 	int (*create)(struct weston_compositor *ec,
-		      EGLenum platform,
-		      void *native_window,
+		      EGLNativeDisplayType display,
 		      const EGLint *attribs,
-		      const EGLint *visual_id,
-		      const int n_ids);
+		      const EGLint *visual_id);
 
 	EGLDisplay (*display)(struct weston_compositor *ec);
 
 	int (*output_create)(struct weston_output *output,
-			     EGLNativeWindowType window_for_legacy,
-			     void *window_for_platform,
+			     EGLNativeWindowType window,
 			     const EGLint *attribs,
-			     const EGLint *visual_id,
-			     const int n_ids);
+			     const EGLint *visual_id);
 
 	void (*output_destroy)(struct weston_output *output);
 
-- 
1.8.3.1

